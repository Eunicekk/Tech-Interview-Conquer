<details>
  <summary>동적 재배치는 어떻게 이루어지나요?</summary>

<br>

  ### 운영체제의 개입 없이 하드웨어를 통해 진행됩니다.
  CPU 속의 베이스 레지스터와 바운드 레지스터 두 개를 이용해 재배치합니다.
  프로그램 실행 시 주소 재배치가 일어나고, 실행 시작 후에도 주소 공간을 이동할 수 있어서 '동적 재배치'로 불립니다.

  1. 프로그램 실행 시 생성되는 모든 주소가 프로세서에 의해 변환됩니다.
  2. 프로세스가 생성하는 메모리 참조는 가상 주소로 되어 있고, 하드웨어에서 베이스 레지스터 값을 가상 주소에 더해서 물리 주소를 생성합니다.
  3. 이때 바운드 레지스터(한계 레지스터)는 가상 주소가 바운드 레지스터의 범위 안에 있는지 확인합니다. (메모리 참조가 합법인지 확인)
  4. 따라서 바운드 레지스터는 항상 16KB로 설정되어 있고, 바운드 레지스터보다 큰 주소거나 음수인 가상 주소는 예외가 발생하고, 프로세스가 종료 됩니다.

  하지만 해당 방식은 비효율적입니다. 프로세스를 재배치하면서 스택과 힙 사이 공간이 낭비되고 있는 '내부 단편화'가 발생합니다.
  물리 메모리 이용률을 높이고, 내부 단편화를 방지하기 위해서는 이 기법을 일반화하여 '세그멘테이션'을 사용할 수 있습니다.
  
</details>
<br>

<details>
  <summary>하드웨어와 운영체제의 요구사항은 어떻게 다른가요?</summary>

<br>

  <하드웨어의 요구사항>
  - 두 가지의 CPU 모드 (특권(커널모드) / 사용자 모드)
  - 베이스/바운드 레지스터
  - 가상 주소 변환하고, 범위 안에 있는지 검사하는 능력
  - 베이스/바운드 갱신을 위한 특권 명령어
  - 예외 핸들러 등록을 위한 명령어
  - 예외 발생 기능

  <운영체제의 요구사항>
  - 메모리 관리
  - 베이스/바운드 관리
  - 예외 처리
  
</details>
<br>
