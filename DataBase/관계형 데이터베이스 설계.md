# 관계형 데이터베이스 설계

---

## 1. 좋은 관계형 설계의 특징

<br>

> 불필요한 중복 없이 정보를 저장하고 쉽게 검색이 가능

<br>

### 1) 중복의 문제

<br>

| ID | name  | salary       | dept_name | building | budget |
|------------|------|------------|----|------------|------|
| 1        | Yang | 95000         | Physics | Watson        | 70000   |
| 2        | Park   | 90000       | Physics | Watson        | 70000    |
| 3        | Lee | 60000         | Finance | Painter        | 120000         |
| 4        | Cho  | 75000    | Finance | Painter        | 120000    |

<br>

- dept_name, building, budget과 같은 학과의 정보를 중복 저장하여 손해
- budget 수정 시 관련 학과를 모두 수정하지 않으면 일관성을 잃을 수 있음

### 2) Null 문제

<br>

- 학과만 신설할 경우 교수 채용 전이라면 ID, name, salary에 null 값을 가지게 됨

### 3) 분해

> 스키마에 문제가 있다면 분해하여 해결 가능

<br>

이전의 스키마를 교수와 학과 스키마로 분해하면 관련 문제를 해결할 수 있음

- 분해로 인해 정보의 손실이 발생한다면 분해하지 말아야 함
- **무손실 분해** : R = πR1(R) ⋈ πR2(R)
- **손실 분해** : R ≠ πR1(R) ⋈ πR2(R)

<기존>
| ID | name  | street       | city | salary |
|------------|------|------------|------------|-----|
| 1        | Yang | Main         | Perryridge | 95000        |
| 2        | Park   | North       | Hampton | 90000        |

<분해>
| ID | name  | |street       | city | salary |
|------------|------|-----|------------|------------|-----|
| 1        | Yang || Main        | Perryridge | 95000        |
| 2        | Park || North       | Hampton | 90000        |

<자연 조인>

| ID | name  | street       | city | salary |
|------------|------|------------|------------|-----|
| 1        | Yang | Main         | Perryridge | 95000        |
| 1        | Yang | North       | Hampton | 90000         |
| 2        | Park | Main         | Perryridge | 95000        |
| 2        | Park | North       | Hampton | 90000        |

- 분해 후 자연 조인 결과가 기존의 릴레이션과 다름
- 실제 거주 위치 급여와 관련 없는 이름과 조인이 일어나게 되어서 불필요한 정보가 생성됨
- 이름과 주소 또는 급여와의 연관 관계 정보가 손실됨

<br>

## 2. 함수 종속을 사용한 분해

<br>

### 1) 적법한 인스턴스

> 데이터베이스의 모든 릴레이션 인스턴스가 실제 세계의 제약 조건을 만족

<br>

### 2) 함수 종속

> 어떤 속성 값이 다른 속성 값을 결정할 수 있는 관계

<br>

- r(R)인스턴스 내 모든 튜플의 쌍 t1, t2가 t1[X] = t2[X]이면, t1[Y] = t2[Y]를 만족하면 **함수 종속** X → Y를 만족
- 함수 종속 X → Y이 성립하면 X는 r(R)인스턴스의 **수퍼키**라는 것을 의미
- 함수 종속 집합 F를 만족하는 r(R)인스턴스에 대해 **F는 r(R)을 보존**한다고 함
- R1 ∩ R2 → R1 또는 R1 ∩ R2 → R2이면 R을 R1과 R2로 분해하는 것은 **무손실 분해**

<br>

## 3. 정규형

<br>

### 1) 보이스-코드 정규형(BCNF)

#### 정의

> 다음 중 적어도 하나라도 만족하면 함수 종속의 집합 F와 관련하여 릴레이션 스키마 R은 BCNF
> - X → Y가 자명한 함수 종속
> - X가 스키마 R의 수퍼 키

<br>

#### 분해

> BCNF 형태가 아닌 스키마는 X → Y에서 BCNF의 정의를 만족하지 않는 경우가 있다면
> - X ∪ Y
> - R - (Y - X)
> 두 개의 스키마로 분해할 수 있음

<br>

#### 예시
1. in_dep (ID, name, salary, dept_name, building, budget)에서 dept_name -> budget이 성립하지만 자명하지도 수퍼키도 아니므로 BCNF가 아님
2. dept_name -> {building, budget}으로 분해
3. X ∪ Y = (dept_name, building, budget), R - (Y - X) = (ID, name, dept_name, salary)로 분해
4. 각각의 릴레이션에서 dept_name, ID가 수퍼키로 BCNF를 만족

<br>

#### 단점
> BCNF는 종속성을 보존하지 않음

1. "학생은 두 명 이상의 지도교수를 둘 수 있지만 주어진 학과에서 최대 한 명의 지도교수를 가진다"라는 제약조건
2. dept_advisor(s_ID, i_ID, dept_name)은 BCNF 분해 규칙에 따라 (s_ID, i_ID)와 (i_ID, dept_name)으로 분해 가능  
3. 학생은 주어진 학과에서 최대 한 명의 지도교수를 가진다라는 s_ID, dept_name -> i_ID의 종속성을 잃어 버림

<br>

### 2) 제3정규형(3NF)

#### 정의

> 다음 중 적어도 하나라도 만족하면 함수 종속의 집합 F와 관련하여 릴레이션 스키마 R은 3NF
> - X → Y가 자명한 함수 종속
> - X가 스키마 R의 수퍼 키
> - Y - X에 속한 각 속성 A는 R의 후보 키

이전의 예시에서 s_ID, dept_name -> i_ID의 s_ID와 dept_name은 각각 후보키이므로 dept_advisor(s_ID, i_ID, dept_name)는 3NF

<br>

#### BCNF vs 3NF

> SQL에서 주 키 제약 조건 이외의 함수 종속 확인이 어려우므로 BCNF 사용을 권장

<br>

#### 함수 종속 기반 정규형의 단점
>정보의 불필요한 중복

교수가 두명의 자식(David, William)과 두개의 전화번호(111-1111, 222-2222)가 있을 때
1. (1, David, 111-1111)
2. (1, David, 222-2222)
3. (1, William, 111-1111)
4. (1, William, 222-2222)  

- 두 개의 튜플만 사용할 경우 대응되어야 할 일부 튜플이 적용 안됨
- 네 개의 튜플을 사용할 경우 정보의 불필요한 중복이 발생

<br>

## 4. 함수 종속 이론

<br>


<br>

### 1) 함수 종속 집합의 폐포
> 함수 종속 집합 F에 대하여 F로부터 논리적으로 유도할 수 있는 모든 함수 종속성을 포함하는 집합 F+

<br>

1. F에 있는 모든 함수 종속성을 초기값으로 설정
2. 암스트롱 공리를 적용하여 추가 함수 종속성 도출
   - 재귀 규칙: 𝑋 ⊇ 𝑌면 𝑋 → 𝑌
   - 증가 규칙: X → Y 면 XZ → YZ
   - 이행 규칙: X → Y,Y → Z면 X → Z
3. 더 이상 새로운 종속성을 도출할 수 없으면 종료

<br>

계산에 직접 활용하기에 암스트롱 공리는 불편하므로 아래의 부가적인 규칙을 사용  
- 연합 규칙 : X → Y,X → Z면 X → YZ
- 분해 규칙 : X → YZ이면 X → Y,X → Z
- 가이행 규칙 : X → Y, ZY → A이면 XZ → A

<br>

**예제**   
R = (A, B, C, G, H, I), F = {A → B, A → C, CG → H, CG → I, B → H}  
- A → B, B → H이므로 이행 규칙에 따라 A → H
- CG → H, CG → I이므로 연합규칙에 따라 CG → HI
- A → C, CG → I이므로 가이행 규칙에 따라 AG → I
  * A → C이면 증가 규칙으로 AG → CG이고 CG → I와 이행 규칙에 따라 AG → I를 추론 가능하지만 가이행 규칙을 적용하면 더 쉽게 구할 수 있음

<br>

### 2) 속성 집합의 폐포
> 함수 종속 집합 F에서 α에 의해 결정되는 모든 속성의 집합 α+

<br>

**예제**   
F = {A → B, B → C, CD → E}
1. 초기상태 A+ = {A}
2. A → B이므로 B 추가 A+ = {A}
3. B → C이므로 C 추가 A+ = {A, B, C}
4. A+에 CD가 없음
5. 결과 : A+ = {A, B, C}

**활용**
- 후보 키(수퍼 키) 판별 : α+가 릴레이션의 모든 속성을 포함하는가
- A → B가 보존 : A+ ⊇ B 확인
- F+ 구하기 : R ⊇ γ인 γ에 대해서 γ+를 구하고 γ+ ⊇ S인 함수 종속 γ → S

<br>

### 3) 캐노니컬 커버
> 함수 종속성 검사의 효율성을 위해 함수 종속 집합 F에서 중복된 함수 종속과 불필요한 속성을 최소화하여 논리적으로 동등하면서 최소한의 함수 종속성만 포함하는 집합

**예제**   
F = {A → BC, B → C, A → B, AB → C}
1. A → BC는 A → B와 B → C로 분해 가능하므로 A → BC 제거
2. AB → C는 A → B와 B → C로 유도 가능하므로 AB → C 제거
3. Fc = {A → B, B → C} (동등한 여러 캐노니컬 커버 존재 가능)

<br>

### 4) 종속성 보존
> 릴레이션 분해 후 종속성이 보존되지 않으면 질의 시 조인이 필요해 오히려 성능이 저하

**예제**   
R(A, B, C), F = {A → B, B → C, A → C}, R1(A, B), R2(B, C)
- R1(A, B)에서 A → B가 유지
- R2(B, C)에서 B → C가 유지
- A → C가 유지되지 않으므로 종속성 보존 실패
